### Séparation Backend Pur / Backend Next.js
- La logique métier réutilisable (parsing, calculs, transformations) doit être dans `utils/` ou `lib/` et être utilisable en ligne de commande
- Principe de séparation des préoccupations (Separation of Concerns) : Chaque module/composant a une seule responsabilité. La logique métier (backend pur) est séparée de la logique de présentation (frontend) et de la génération HTML (backend Next.js)

#### Tests BDD
- Tests BDD (Cucumber) pour les scénarios utilisateur : Les scénarios Gherkin expriment les intentions métier et sont lisibles par les non-développeurs

#### TDD Obligatoire avec Ordre Strict
- Pour toute fonction backend pur (`utils/`), le cycle TDD DOIT être respecté dans l'ordre suivant :
  1. RED : Écrire le test d'abord (le test échoue)
  2. GREEN : Écrire le code minimal pour faire passer le test
  3. REFACTOR : Refactoriser le code tout en maintenant les tests verts
- Interdiction absolue : Aucune fonction exportée dans `utils/` ne doit être créée sans son fichier de test correspondant créé en premier
- Vérification avant code : Avant d'écrire du code dans `utils/`, créer d'abord le fichier de test `tests/unit/[nomFonction].test.ts` avec au moins un test qui échoue

#### Progression TDD du Simple au Complexe
- Les tests DOIVENT suivre une progression explicite du cas le plus simple au cas le plus complexe. Chaque test ajoute une complexité minimale et fait émerger le code étape par étape, sans le complexifier inutilement dès la première implémentation
- Les tests ne doivent pas être de simples tests de "couverture de code" ou de "non-régression" écrits après coup, mais une suite de tests progressive qui fait émerger le code du simple au complexe
- Exemple de progression :
  - Test 1 : Le cas le plus simple (une seule fonctionnalité de base)
  - Test 2 : Ajouter une deuxième fonctionnalité simple
  - Test 3 : Ajouter une troisième fonctionnalité simple
  - Test 4 : Combiner plusieurs fonctionnalités
  - Test 5 : Ajouter des cas limites
  - Test 6 : Ajouter des cas d'erreur et robustesse

#### Tests Unitaires Obligatoires
- Tests unitaires (TDD) obligatoires pour TOUTES les fonctions backend pur : Chaque fonction exportée dans `utils/` doit avoir des tests unitaires complets
- Tests passent sans erreurs avant commit
- Mocking approprié des dépendances externes (`next/image`, `window`, `next/navigation`)
- Couverture de tests : Les fonctions backend pur doivent avoir une couverture de tests complète (cas normaux, cas limites, cas d'erreur)

#### Code Legacy Non Testé
- Les fonctions créées avant cette règle doivent être couvertes par des tests dans le cadre d'un refactoring, mais jamais utilisées comme excuse pour créer du nouveau code sans tests
- Refactorisation du code non conforme : Si du code métier a été créé sans respecter le TDD (tests écrits après le code ou tests de couverture/non-régression), il doit être refactorisé en partant de zéro : supprimer le code existant, supprimer les tests existants, puis faire réémerger les tests puis le code en suivant strictement la progression TDD du simple au complexe

#### Processus de Développement Strict
- Pour toute nouvelle fonctionnalité dans `utils/`, le fichier de test doit exister AVANT le fichier de code
- Si un fichier `utils/maFonction.ts` est créé, il DOIT exister un fichier `tests/unit/maFonction.test.ts` créé au préalable
