### Definition of Done (DOD) - Règles générales

**Dernière mise à jour** : 2026-01-20 (issue de la rétrospective Glad-Sad-Mad)

---

#### PHASE 1 : AVANT LE CODAGE (Validation et Compréhension)

##### 1.1 Validation de la demande

**Règle absolue** : **NE JAMAIS CODER AVANT VALIDATION COMPLÈTE**

1. **Reformuler la demande** :
   - Reformuler clairement ce que l'utilisateur demande
   - Identifier les ambiguïtés ou les points non clairs
   - **Demander validation explicite** avant de continuer

2. **Distinguer demande fonctionnelle vs technique** :
   - **Demande fonctionnelle/métier** → Suivre le processus complet User Story → BDD → Technique → Code
   - **Demande purement technique** (syntaxe, erreur évidente) → Peut passer directement au code

3. **Éviter la complexité inutile** :
   - Quand une demande semble simple, proposer d'abord la solution la plus simple possible
   - Ne pas gérer tous les cas possibles s'ils ne sont pas demandés
   - Si la demande est ambiguë, demander clarification avant de proposer une solution

##### 1.2 Reformulation en User Story (pour demandes fonctionnelles)

**Processus obligatoire** :

1. Reformuler la demande en User Story (format : "En tant que [rôle], je veux [action] afin de [bénéfice]")
2. Identifier le problème métier réel à résoudre
3. **Valider la User Story avec l'utilisateur avant de continuer**

##### 1.3 BDD - Behavior-Driven Development (pour demandes fonctionnelles)

**Processus obligatoire** :

1. Une fois la User Story validée, créer les scénarios BDD (format Gherkin en français)
2. Scénarios avec Given/When/Then
3. **Valider les scénarios BDD avec l'utilisateur avant de continuer**

##### 1.4 Approche technique (pour demandes fonctionnelles)

**Processus obligatoire** :

1. Expliquer comment je compte m'y prendre techniquement
2. Lister les tâches techniques que je vais réaliser
3. **Discuter avec l'utilisateur de l'approche avant de coder**

##### 1.5 Choix autonomes importants

**Règle** : Pour les choix de design/structure importants :
- Proposer plusieurs options ou demander validation explicite
- Ne pas faire de choix autonomes sur des éléments critiques (icônes, structure, architecture)

---

#### PHASE 2 : PENDANT LE CODAGE (TDD et Structure)

##### 2.1 Tests-Driven Development (TDD) - PRIORITÉ ABSOLUE

**Règle stricte** : **TESTS D'ABORD, CODE ENSUITE**

**Objectif du TDD** : Le TDD n'est **pas** une métrique de couverture, mais une **discipline de développement** qui vise à faire émerger le code le plus simple possible.

**Référence** : Voir `A propos de ce site/6. Questions et arbitrages/TDD strict - Enquête bibliographique.md`

1. **Suivre strictement le cycle RED → GREEN → REFACTOR - UN TEST À LA FOIS** :
   - **RED** : Écrire **un seul test** qui échoue (le plus simple possible)
   - **GREEN** : Écrire le **code minimal** pour faire passer ce test (pas plus)
   - **REFACTOR** : Améliorer le code en gardant les tests verts (nommage métier/DDD, lisibilité)
   - **PUIS SEULEMENT** : Passer au test suivant

2. **Règles strictes d'implémentation** :

   a. **One test at a time (un test à la fois)** :
      - Ne jamais écrire plusieurs tests en même temps
      - Se concentrer sur un seul comportement à la fois
      - Éviter la complexité inutile (ne pas tester des cas non nécessaires)

   b. **Smallest possible test first (commencer par le cas le plus simple)** :
      - Toujours commencer par le cas le plus simple possible (ex: fichier vide, puis 1 ligne, etc.)
      - Progresser incrémentalement : du simple au complexe
      - Valider rapidement que le test fonctionne avant de complexifier

   c. **Minimal code (code minimal pour faire passer le test)** :
      - Écrire **juste assez** de code pour faire passer le test
      - **Ne pas** implémenter plus que ce que le test exige
      - **Ne pas** gérer tous les cas possibles si non demandés
      - Principe YAGNI : You Aren't Gonna Need It

   d. **Refactor after each green (refactoriser après chaque test vert)** :
      - **Toujours** refactoriser après chaque test vert avant de passer au suivant
      - Améliorer la lisibilité (nommage métier/DDD)
      - Maintenir la qualité du code (pas de dette technique)
      - Éviter l'accumulation de code "quick hack"

3. **Couverture de code à 100%** :
   - La couverture doit être maintenue à **100%** sur tous les critères (lignes, statements, functions, branches)
   - Chaque nouveau code doit avoir ses tests unitaires **AVANT** d'être validé
   - Si la couverture descend en dessous de 100%, corriger immédiatement
   - Exécuter `npm test -- --coverage` régulièrement pour vérifier la couverture

4. **Ordre d'implémentation strict** :
   - **Étape 1** : Écrire un test (RED) - le plus simple possible
   - **Étape 2** : Écrire le code minimal pour faire passer le test (GREEN)
   - **Étape 3** : Refactoriser le code (REFACTOR)
   - **Étape 4** : Passer au test suivant (retour à l'étape 1)
   - Respecter les BDD validés dans chaque étape

##### 2.2 Structure et Organisation du Code

**Règles de structure** :

1. **Organisation des fichiers** :
   - Chaque section doit être un composant React fonctionnel dans le dossier `components/`
   - Les textes statiques doivent être extraits dans des fichiers JSON dans `data/`
   - La configuration statique (images, constantes de configuration) doit être dans `constants/` (pas dans les composants)
   - Utilisation de CSS Modules avec un fichier CSS par composant
   - Header et Footer factorisés dans le layout pour être partagés par toutes les pages
   - Structure de dossiers claire : `components/`, `types/`, `constants/`, `data/`, `app/`, `utils/`, `tests/`

2. **Références et Chemins** :
   - Images stockées dans `public/images/` et référencées avec des chemins absolus
   - Routes centralisées dans `constants/routes.ts`
   - Pas de chemins relatifs complexes (max 2 niveaux)

##### 2.3 Types et Interfaces TypeScript

**Règles de typage** :

1. Tous les composants doivent avoir des types TypeScript définis
2. Les interfaces communes doivent être dans `types/`
3. Les constantes (routes, couleurs, configuration) doivent être dans `constants/`
4. Types stricts sans utilisation de `any` sauf cas justifiés (ex: mocks dans les tests)
5. Configuration des composants (images, dimensions, etc.) séparée des composants eux-mêmes dans `constants/`

##### 2.4 Code Propre et Maintenable

**Règles de qualité** :

1. Pas de code mort : suppression des composants et fichiers inutilisés
2. Pas de duplication : factorisation des styles et logique commune
3. Composants purs et simples avec responsabilités uniques (Single Responsibility Principle)
4. Noms de variables et fonctions explicites et en français pour le domaine métier
5. Code documenté avec commentaires pour les logiques complexes
6. Documentation pédagogique : Les commentaires dans le code doivent expliquer le "pourquoi" et non seulement le "comment", pour faciliter l'apprentissage (contexte : Product Manager se formant avec une IA)

##### 2.5 Modifications incrémentales

**Règle** : Pour permettre l'interruption facile :
- Faire des changements par petits pas
- Avec pauses entre chaque étape pour permettre feedback
- Ne pas tout modifier d'un coup

---

#### PHASE 3 : APRÈS LE CODAGE (Validation et Documentation)

##### 3.1 Vérification de qualité

**Règles de vérification** :

1. **Linters** : Après chaque modification de code :
   - Lancer `read_lints` sur les fichiers modifiés
   - Corriger automatiquement les erreurs de linting si évidentes
   - Signaler les erreurs non évidentes à l'utilisateur

2. **Build** : Après modifications importantes :
   - Lancer `npm run build` pour vérifier que le projet compile
   - Si erreur de build, corriger avant de publier
   - Ne pas publier si le build échoue

3. **Tests** : Après chaque modification :
   - Lancer les tests pertinents (pas tous les tests à chaque modification)
   - Vérifier que tous les tests passent
   - Vérifier la couverture de code

##### 3.2 Collecte des métriques

**Règles automatiques** :

1. Lors de chaque build, lancer automatiquement `npm run metrics:collect` pour collecter les métriques
2. Les métriques doivent être collectées et stockées dans `public/metrics/`
3. L'historique des métriques doit être maintenu pour suivre l'évolution

##### 3.3 Navigation et Routing

**Règles de navigation** :

1. Navigation avec `next/navigation useRouter` pour les liens internes
2. Ouverture des liens externes avec `window.open` et sécurisation (`noopener`, `noreferrer`)
3. Commandes de navigation mappées dans `COMMAND_TO_ROUTE`
4. Gestion cohérente des clics sur logo et photo dans Header

##### 3.4 Tenue du Journal de Bord - PRIORITÉ ABSOLUE

**Règle obligatoire** : À chaque prompt qui modifie le code ou la structure du projet :

1. **Vérifier l'existence du fichier journal du jour** dans `A propos de ce site/4. Journal de bord/` (format `YYYY-MM-DD.md`)
2. **Créer le fichier si nécessaire**
3. Si un nouveau sujet est exploré, créer une nouvelle partie avec `### Titre du sujet` (H3)
4. **Ajouter le prompt dans le journal** avec :
   - `#### Titre du prompt` (H4) - titre descriptif du prompt
   - `##### Prompt` (H5) - le prompt exact de l'utilisateur (corriger fautes d'orthographe/syntaxe)
   - `##### Résultat technique` (H5) - résumé technique de la réponse apportée

**Critères** :
- Prompt qui modifie le code → **OUI** (ajouter au journal)
- Prompt théorique/formation → **NON** (créer un cours dans `5. Cours/`)
- Prompt de diagnostic/question → **OUI** (ajouter au journal)
- Prompt de publication Git → **OUI** (ajouter au journal)

**Règle de validation importante** :
- Les fichiers journal doivent respecter les règles de validation des fichiers MD :
  - **Aucun titre H1 (#) ou H2 (##) ne doit être présent** dans le fichier
  - Les fichiers doivent commencer au niveau 3 (###)
  - Si un exemple de format contient des titres H1/H2, il doit être mis dans un bloc de code markdown (```) pour être ignoré par le parser
  - Cette règle est validée lors des tests et doit faire échouer le build si non respectée

**Sauvegarde des prompts** : Après chaque US ou session importante, proposer explicitement de mettre à jour le journal si ce n'est pas déjà fait.

---

#### PHASE 4 : GESTION DES USER STORIES PAR SPRINT

##### 4.1 Identification du Sprint en cours

**Règle** : Les User Stories sont organisées dans le dossier `A propos de ce site/2. Sprints/` avec un fichier MD par Sprint.

1. **Identifier le Sprint en cours** :
   - Le Sprint en cours est le dernier fichier créé dans `A propos de ce site/2. Sprints/`
   - Vérifier la date de modification pour identifier le dernier fichier
   - Le format est : `YYYY-MM-DD - Titre du Sprint.md`

2. **Rester focus sur le Sprint en cours** :
   - L'IA doit rester concentrée sur l'objectif du Sprint en cours
   - Ne pas se détourner vers d'autres sujets non liés au Sprint en cours
   - Si l'utilisateur dérive vers d'autres sujets, l'alerter poliment

##### 4.2 Écriture des User Stories

**Règles** :

1. Toutes les nouvelles User Stories doivent être écrites dans le fichier du Sprint en cours
2. Respecter le format existant : `#### US-X.Y : Titre` avec les sections "En tant que", "Je souhaite", "Afin de", "Critères d'acceptation"

##### 4.3 Détection de dérive et alerte

**Règle** :
- **Si focus** : L'utilisateur travaille sur le Sprint en cours → Continuer à écrire les US dans le Sprint en cours
- **Si pas focus** : L'utilisateur dérive vers d'autres sujets → Alerter l'utilisateur : "Je remarque que nous nous éloignons du Sprint en cours [nom du Sprint]. Souhaitez-vous continuer sur ce Sprint ou passer à autre chose ?"
- Ne pas imposer, mais signaler la dérive pour maintenir la cohérence

**Critères de détection de dérive** :
- Demande de fonctionnalité non liée au Sprint en cours
- Discussion sur un autre sujet que celui du Sprint
- Demande de modification d'un autre Sprint
- Demande de créer une nouvelle fonctionnalité qui n'est pas dans le Sprint en cours

**Exception** : Les demandes techniques de correction d'erreurs, de refactoring, ou de maintenance peuvent être traitées même si elles ne sont pas directement liées au Sprint en cours.

##### 4.4 Structure des Critères d'acceptation

**Règle** : Lorsque j'écris une User Story dans le wiki du site, je dois respecter la structure suivante pour la section "Critères d'acceptation" :

1. **Structure hiérarchique** :
   - La section "Critères d'acceptation" commence par la ligne `- **Critères d'acceptation** :`
   - Cette section se termine à :
     - La prochaine User Story (ligne commençant par `#### US-`)
     - Un séparateur `---`
     - La fin de la sous-partie (H4)

2. **Thèmes de critères** :
   - Si une ligne commence par `- **` (avec `**` au début) : c'est un "Thème de critère" (puce de niveau 1, texte en gras)
   - Format : `- **Thème de critère** :` (ex: `- **CSS responsive** :`)
   - Le texte entre `**` est affiché en gras par le parser Markdown

3. **Critères normaux** :
   - Si une ligne commence par `- ` (sans `**` au début) : c'est un "Critère" (puce de niveau 2, texte normal, indenté sous le thème précédent)
   - Format : `- Critère normal` (ex: `- Un bloc conteneur principal...`)
   - Les critères sont automatiquement associés au dernier thème rencontré

4. **Hiérarchie visuelle** :
   - Les thèmes de critères s'affichent avec une puce de niveau 1 (pas d'indentation supplémentaire) et en gras
   - Les critères normaux s'affichent avec une puce de niveau 2 (indentés sous leur thème) et en texte normal
   - La hiérarchie visuelle est claire grâce à l'indentation et au style (gras/normal)

---

#### PHASE 5 : GESTION DES QUESTIONS ET ARBITRAGES

##### 5.1 Création de fichiers d'arbitrage

**Règle** : Lorsque l'utilisateur pose une question de fond sur l'architecture, un arbitrage à faire, ou une stratégie à adopter :

1. **Créer un fichier dans le dossier `A propos de ce site/6. Questions et arbitrages/`**
2. **Nom du fichier** : Utiliser un nom descriptif en minuscules avec des espaces (pas de majuscules, pas d'underscores)
   - Format : `Titre descriptif.md` (ex: "Analyse architecture unifiée.md")
   - Éviter : `ANALYSE_ARCHITECTURE.md` ou `Analyse_Architecture.md`
3. **Contenu** : 
   - Inclure la question de l'utilisateur
   - Inclure la réponse/analyse/arbitrage proposé
   - Respecter la structure Markdown (titres maximum H3 - ###)
4. **Objectif** : Conserver la trace des questions importantes et des décisions d'architecture

**Exemples de questions qui nécessitent un fichier d'arbitrage** :
- Questions sur l'architecture du projet
- Arbitrages techniques à faire
- Stratégies à adopter
- Analyses comparatives de solutions
- Plans de refactorisation

##### 5.2 Création de fichiers de cours

**Règle** : Si l'utilisateur pose une question théorique de formation :

1. Créer un fichier dans `A propos de ce site/5. Cours/`
2. Format : `##. Titre du cours.md` (numérotation chronologique)
3. Contenu avec titre maximum H3 (###)

---

#### PHASE 6 : COMMUNICATION ET GESTION DES ERREURS

##### 6.1 Communication en français

**Règle** : Toutes les communications avec l'utilisateur :
1. Toujours en français (selon les règles utilisateur)
2. Explications pédagogiques pour les concepts techniques
3. Citations de code avec le format `startLine:endLine:filepath`

##### 6.2 Gestion des erreurs

**Règle** : En cas d'erreur :
1. **Identifier d'abord le problème métier/fonctionnel** avant de proposer une solution technique
2. Analyser l'erreur complètement avant de proposer une solution
3. Ne pas faire de corrections multiples en parallèle sans comprendre la cause
4. Proposer une solution simple avant une solution complexe
5. Si plusieurs tentatives échouent, proposer de repartir de zéro avec User Story → BDD → TDD

##### 6.3 Amélioration des ajustements CSS

**Règle** : Pour éviter les aller-retours longs sur les ajustements CSS :
1. Demander plus de précisions (screenshots, mesures, descriptions détaillées)
2. Suggérer d'utiliser les outils de développement du navigateur pour identifier précisément les styles
3. Faire des modifications incrémentales avec pauses pour feedback

---

#### PHASE 7 : AUTRES COMPORTEMENTS AUTOMATIQUES

##### 7.1 Recherche dans le codebase

**Règle** : Avant de modifier du code :
1. Utiliser `codebase_search` pour comprendre le contexte
2. Lire les fichiers pertinents avec `read_file`
3. Vérifier les tests existants avec `grep` ou `read_file`
4. Comprendre l'architecture avant de modifier

##### 7.2 Création de todos pour tâches complexes

**Règle** : Pour les tâches avec 3+ étapes distinctes :
1. Créer une liste de todos avec `todo_write`
2. Marquer les todos comme `in_progress` / `completed` au fur et à mesure
3. Ne pas créer de todos pour les tâches triviales (< 3 étapes)

##### 7.3 Vérification des dépendances

**Règle** : Avant d'ajouter une nouvelle dépendance :
1. Vérifier si une solution native existe
2. Vérifier la compatibilité avec les versions actuelles
3. Proposer l'ajout dans `package.json` avec justification

##### 7.4 Publication Git automatique

**Règle** : Après chaque modification validée :
1. `git add -A` pour ajouter tous les changements
2. `git commit -m "Message descriptif"` avec un message clair
3. `git push` pour publier sur GitHub
4. **Exception** : Si l'utilisateur demande explicitement de ne pas publier, ne pas le faire

---

#### COMPORTEMENTS À NE PAS FAIRE AUTOMATIQUEMENT

##### Ne pas créer de fichiers de documentation

**Règle** : Ne pas créer de fichiers `.md` de documentation sauf demande explicite (sauf pour les fichiers d'arbitrage qui doivent être créés automatiquement dans `6. Questions et arbitrages/`)

##### Ne pas modifier de fichiers non demandés

**Règle** : Ne modifier que les fichiers explicitement mentionnés ou nécessaires pour la tâche

##### Ne pas exécuter tous les tests à chaque modification

**Règle** : Ne pas lancer tous les tests à chaque modification, seulement les tests pertinents

##### Ne pas refactoriser sans demande

**Règle** : Ne pas refactoriser du code qui fonctionne sauf demande explicite

---

#### RÉSUMÉ DES PRIORITÉS ABSOLUES

**À respecter en TOUTE CIRCONSTANCE** :

1. ✅ **NE JAMAIS CODER AVANT VALIDATION COMPLÈTE** (Phase 1)
2. ✅ **TESTS D'ABORD, CODE ENSUITE** - TDD strict avec couverture 100% (Phase 2.1)
3. ✅ **JOURNAL DE BORD TOUJOURS À JOUR** - Après chaque modification (Phase 3.4)
4. ✅ **RESPECTER LE DOD** - Vérifier avant chaque action que le DOD est respecté
