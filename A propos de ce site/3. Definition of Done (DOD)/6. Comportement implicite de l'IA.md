### Comportement implicite de l'IA à chaque prompt

#### Intention
Décrire explicitement tous les comportements automatiques que l'IA doit exécuter à chaque prompt, sans instruction explicite de l'utilisateur.

#### Approche méthodologique : Fonctionnel avant Technique

**Principe fondamental** : La technique n'est qu'un moyen pour atteindre un but. Il faut d'abord confirmer le problème à régler avant de se lancer vers une solution.

**Processus obligatoire pour les demandes fonctionnelles/métier** :

1. **Reformulation en User Story** :
   - Reformuler la demande fonctionnelle en User Story (format : "En tant que [rôle], je veux [action] afin de [bénéfice]")
   - Identifier le problème métier réel à résoudre
   - Valider la User Story avec l'utilisateur avant de continuer

2. **BDD (Behavior-Driven Development)** :
   - Une fois la User Story validée, créer les scénarios BDD (format Gherkin)
   - Scénarios en français avec Given/When/Then
   - Valider les scénarios BDD avec l'utilisateur avant de continuer

3. **Explication de l'approche technique** :
   - Une fois les BDD validés, expliquer comment je compte m'y prendre
   - Lister les tâches techniques que je vais réaliser
   - Discuter avec l'utilisateur de l'approche avant de coder

4. **Implémentation** :
   - Coder seulement après validation de l'approche technique
   - Suivre TDD strict (RED → GREEN → REFACTOR)
   - Respecter les BDD validés

**Exception** : Pour les demandes purement techniques (ex: "corrige cette erreur de syntaxe"), on peut passer directement à l'implémentation.

#### Comportements automatiques obligatoires

##### 1. Mise à jour du journal de bord
**Règle** : À chaque prompt qui modifie le code ou la structure du projet :
1. Vérifier l'existence du fichier journal du jour dans `A propos de ce site/4. Journal de bord/` (format `YYYY-MM-DD.md`)
2. Créer le fichier si nécessaire
3. Si un nouveau sujet est exploré, créer une nouvelle partie avec `### Titre du sujet` (H3)
4. Ajouter le prompt dans le journal avec :
   - `#### Titre du prompt` (H4) - titre descriptif du prompt
   - `##### Prompt` (H5) - le prompt exact de l'utilisateur (corriger fautes d'orthographe/syntaxe)
   - `##### Résultat technique` (H5) - résumé technique de la réponse apportée

**Critères** :
- Prompt qui modifie le code → OUI (ajouter au journal)
- Prompt théorique/formation → NON (créer un cours dans `5. Cours/`)
- Prompt de diagnostic/question → OUI (ajouter au journal)
- Prompt de publication Git → OUI (ajouter au journal)

**Règle de validation importante** :
- Les fichiers journal doivent respecter les règles de validation des fichiers MD :
  - **Aucun titre H1 (#) ou H2 (##) ne doit être présent** dans le fichier
  - Les fichiers doivent commencer au niveau 3 (###)
  - Si un exemple de format contient des titres H1/H2, il doit être mis dans un bloc de code markdown (```) pour être ignoré par le parser
  - Cette règle est validée lors des tests et doit faire échouer le build si non respectée

##### 2. Vérification des linters
**Règle** : Après chaque modification de code :
1. Lancer `read_lints` sur les fichiers modifiés
2. Corriger automatiquement les erreurs de linting si évidentes
3. Signaler les erreurs non évidentes à l'utilisateur

##### 3. Vérification du build
**Règle** : Après modifications importantes :
1. Lancer `npm run build` pour vérifier que le projet compile
2. Si erreur de build, corriger avant de publier
3. Ne pas publier si le build échoue

##### 4. Publication Git automatique
**Règle** : Après chaque modification validée :
1. `git add -A` pour ajouter tous les changements
2. `git commit -m "Message descriptif"` avec un message clair
3. `git push` pour publier sur GitHub
4. **Exception** : Si l'utilisateur demande explicitement de ne pas publier, ne pas le faire

##### 5. Création de todos pour tâches complexes
**Règle** : Pour les tâches avec 3+ étapes distinctes :
1. Créer une liste de todos avec `todo_write`
2. Marquer les todos comme `in_progress` / `completed` au fur et à mesure
3. Ne pas créer de todos pour les tâches triviales (< 3 étapes)

##### 6. Recherche dans le codebase
**Règle** : Avant de modifier du code :
1. Utiliser `codebase_search` pour comprendre le contexte
2. Lire les fichiers pertinents avec `read_file`
3. Vérifier les tests existants avec `grep` ou `read_file`
4. Comprendre l'architecture avant de modifier

##### 7. Respect du DOD
**Règle** : Avant chaque action :
1. Vérifier que l'action respecte les règles du DOD
2. Si une règle du DOD n'est pas respectée, la signaler et proposer une correction
3. Pour les règles TDD/BDD, suivre strictement RED → GREEN → REFACTOR
4. **Priorité absolue** : Toujours penser fonctionnel/métier avant technique

##### 7bis. Processus User Story → BDD → Technique → Code
**Règle** : Pour toute demande fonctionnelle/métier :
1. **Étape 1 - User Story** : Reformuler en User Story (format : "En tant que [rôle], je veux [action] afin de [bénéfice]") et valider avec l'utilisateur
2. **Étape 2 - BDD** : Créer les scénarios BDD (format Gherkin en français) et valider avec l'utilisateur
3. **Étape 3 - Approche technique** : Expliquer les tâches techniques que je vais réaliser et discuter avec l'utilisateur
4. **Étape 4 - Code** : Coder seulement après validation de toutes les étapes précédentes, en suivant TDD strict
5. **Exception** : Demandes purement techniques (syntaxe, erreurs évidentes) peuvent passer directement au code

##### 8. Gestion des erreurs
**Règle** : En cas d'erreur :
1. **Identifier d'abord le problème métier/fonctionnel** avant de proposer une solution technique
2. Analyser l'erreur complètement avant de proposer une solution
3. Ne pas faire de corrections multiples en parallèle sans comprendre la cause
4. Proposer une solution simple avant une solution complexe
5. Si plusieurs tentatives échouent, proposer de repartir de zéro avec User Story → BDD → TDD

##### 9. Communication en français
**Règle** : Toutes les communications avec l'utilisateur :
1. Toujours en français (selon les règles utilisateur)
2. Explications pédagogiques pour les concepts techniques
3. Citations de code avec le format `startLine:endLine:filepath`

##### 10. Vérification des dépendances
**Règle** : Avant d'ajouter une nouvelle dépendance :
1. Vérifier si une solution native existe
2. Vérifier la compatibilité avec les versions actuelles
3. Proposer l'ajout dans `package.json` avec justification

##### 12. Création de fichiers d'arbitrage et de questions
**Règle** : Lorsque l'utilisateur pose une question de fond sur l'architecture, un arbitrage à faire, ou une stratégie à adopter :

1. **Créer un fichier dans le dossier `A propos de ce site/6. Questions et arbitrages/`**
2. **Nom du fichier** : Utiliser un nom descriptif en minuscules avec des espaces (pas de majuscules, pas d'underscores)
   - Format : `Titre descriptif.md` (ex: "Analyse architecture unifiée.md")
   - Éviter : `ANALYSE_ARCHITECTURE.md` ou `Analyse_Architecture.md`
3. **Contenu** : 
   - Inclure la question de l'utilisateur
   - Inclure la réponse/analyse/arbitrage proposé
   - Respecter la structure Markdown (titres maximum H3 - ###)
4. **Objectif** : Conserver la trace des questions importantes et des décisions d'architecture

**Exemples de questions qui nécessitent un fichier d'arbitrage** :
- Questions sur l'architecture du projet
- Arbitrages techniques à faire
- Stratégies à adopter
- Analyses comparatives de solutions
- Plans de refactorisation

#### Comportements à NE PAS faire automatiquement

##### 1. Création de fichiers de documentation
**Règle** : Ne pas créer de fichiers `.md` de documentation sauf demande explicite (sauf pour les fichiers d'arbitrage qui doivent être créés automatiquement dans `6. Questions et arbitrages/`)

##### 2. Modification de fichiers non demandés
**Règle** : Ne modifier que les fichiers explicitement mentionnés ou nécessaires pour la tâche

##### 3. Exécution de tests complets
**Règle** : Ne pas lancer tous les tests à chaque modification, seulement les tests pertinents

##### 4. Refactorisation non demandée
**Règle** : Ne pas refactoriser du code qui fonctionne sauf demande explicite

#### Exceptions et cas particuliers

##### Prompt de diagnostic
Si l'utilisateur signale un problème :
1. **Identifier le problème métier/fonctionnel** : Quel est le problème réel pour l'utilisateur ?
2. Reformuler en User Story si c'est un problème fonctionnel
3. Analyser le problème technique en profondeur
4. Proposer un diagnostic avant de corriger
5. Valider la stratégie avec l'utilisateur avant d'agir

##### Prompt de formation
Si l'utilisateur pose une question théorique :
1. Créer un fichier dans `A propos de ce site/5. Cours/`
2. Format : `##. Titre du cours.md` (numérotation chronologique)
3. Contenu avec titre maximum H3 (###)

##### Prompt de publication
Si l'utilisateur demande explicitement de publier :
1. Vérifier que tout fonctionne (build, tests)
2. Publier immédiatement sans attendre
3. Confirmer la publication

##### 11. Gestion des User Stories par Sprint
**Règle** : Les User Stories sont organisées dans le dossier `A propos de ce site/2. Sprints/` avec un fichier MD par Sprint.

**Comportements obligatoires** :

1. **Identifier le Sprint en cours** :
   - Le Sprint en cours est le dernier fichier créé dans `A propos de ce site/2. Sprints/`
   - Vérifier la date de modification pour identifier le dernier fichier
   - Le format est : `YYYY-MM-DD - Titre du Sprint.md`

2. **Écrire les User Stories dans le Sprint en cours** :
   - Toutes les nouvelles User Stories doivent être écrites dans le fichier du Sprint en cours
   - Respecter le format existant : `#### US-X.Y : Titre` avec les sections "En tant que", "Je souhaite", "Afin de", "Critères d'acceptation"

3. **Rester focus sur le Sprint en cours** :
   - L'IA doit rester concentrée sur l'objectif du Sprint en cours
   - Ne pas se détourner vers d'autres sujets non liés au Sprint en cours
   - Si l'utilisateur dérive vers d'autres sujets, l'alerter poliment

4. **Détection de dérive et alerte** :
   - **Si focus** : L'utilisateur travaille sur le Sprint en cours → Continuer à écrire les US dans le Sprint en cours
   - **Si pas focus** : L'utilisateur dérive vers d'autres sujets → Alerter l'utilisateur : "Je remarque que nous nous éloignons du Sprint en cours [nom du Sprint]. Souhaitez-vous continuer sur ce Sprint ou passer à autre chose ?"
   - Ne pas imposer, mais signaler la dérive pour maintenir la cohérence

5. **Clôture de Sprint et nouveau Sprint** :
   - Si l'utilisateur décide de clore le Sprint en cours et d'en démarrer un nouveau :
     - Aider à rédiger le Sprint Goal pour le nouveau Sprint
     - Créer un nouveau fichier dans `A propos de ce site/2. Sprints/` avec le format : `YYYY-MM-DD - Titre du Sprint.md`
     - Commencer le fichier par `### Sprint Goal` (H3) suivi du Sprint Goal rédigé
     - Les User Stories suivantes seront écrites dans ce nouveau fichier

**Critères de détection de dérive** :
- Demande de fonctionnalité non liée au Sprint en cours
- Discussion sur un autre sujet que celui du Sprint
- Demande de modification d'un autre Sprint
- Demande de créer une nouvelle fonctionnalité qui n'est pas dans le Sprint en cours

**Exception** : Les demandes techniques de correction d'erreurs, de refactoring, ou de maintenance peuvent être traitées même si elles ne sont pas directement liées au Sprint en cours.

##### 13. Écriture des "Critères d'acceptation" dans les User Stories
**Règle** : Lorsque j'écris une User Story dans le wiki du site, je dois respecter la structure suivante pour la section "Critères d'acceptation" :

1. **Structure hiérarchique** :
   - La section "Critères d'acceptation" commence par la ligne `- **Critères d'acceptation** :`
   - Cette section se termine à :
     - La prochaine User Story (ligne commençant par `#### US-`)
     - Un séparateur `---`
     - La fin de la sous-partie (H4)

2. **Thèmes de critères** :
   - Si une ligne commence par `- **` (avec `**` au début) : c'est un "Thème de critère" (puce de niveau 1, texte en gras)
   - Format : `- **Thème de critère** :` (ex: `- **CSS responsive** :`)
   - Le texte entre `**` est affiché en gras par le parser Markdown

3. **Critères normaux** :
   - Si une ligne commence par `- ` (sans `**` au début) : c'est un "Critère" (puce de niveau 2, texte normal, indenté sous le thème précédent)
   - Format : `- Critère normal` (ex: `- Un bloc conteneur principal...`)
   - Les critères sont automatiquement associés au dernier thème rencontré

4. **Hiérarchie visuelle** :
   - Les thèmes de critères s'affichent avec une puce de niveau 1 (pas d'indentation supplémentaire) et en gras
   - Les critères normaux s'affichent avec une puce de niveau 2 (indentés sous leur thème) et en texte normal
   - La hiérarchie visuelle est claire grâce à l'indentation et au style (gras/normal)

**Exemple de structure correcte** :
```markdown
- **Critères d'acceptation** :
- **Détection du format dans le parseur** :
- Le parseur détecte les éléments...
- La section commence par...
- **Structure de données** :
- Les éléments sont enrichis...
- Les thèmes sont distingués...
```

**Important** : Cette structure permet au parser de détecter automatiquement les thèmes et critères et de les afficher avec les styles CSS appropriés (gras pour les thèmes, normal et indenté pour les critères).

#### Amélioration continue

Ce document doit être mis à jour si de nouveaux comportements implicites sont identifiés ou si des comportements actuels posent problème.

