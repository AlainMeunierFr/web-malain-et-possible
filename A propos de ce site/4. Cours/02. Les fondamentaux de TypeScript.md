### üéØ Qu'est-ce que TypeScript ?

#### D√©finition simple

**TypeScript** = **JavaScript** + **Types statiques**

**Analogie** : 
- JavaScript = Un langage dynamique (comme 4D sans d√©claration de type explicite)
- TypeScript = JavaScript avec des **types d√©clar√©s** (comme si vous d√©clariez `C_TEXT`, `C_LONGINT` en 4D)

**Exemple simple :**

**JavaScript (sans types) :**
```javascript
function addition(a, b) {
  return a + b;
}

addition(5, 3);      // ‚úÖ Fonctionne : 8
addition("5", "3");  // ‚ö†Ô∏è Fonctionne mais retourne "53" (concat√©nation)
addition(5, "3");    // ‚ö†Ô∏è Fonctionne mais retourne "53" (conversion implicite)
```

**TypeScript (avec types) :**
```typescript
function addition(a: number, b: number): number {
  return a + b;
}

addition(5, 3);      // ‚úÖ Fonctionne : 8
addition("5", "3");  // ‚ùå ERREUR : TypeScript refuse car "5" n'est pas un number
addition(5, "3");    // ‚ùå ERREUR : TypeScript refuse car "3" n'est pas un number
```

**Avantage** : TypeScript **d√©tecte les erreurs avant l'ex√©cution** (√† la compilation), comme si 4D vous disait "Ce champ est C_TEXT, vous ne pouvez pas y mettre un nombre" avant d'ex√©cuter.

---

### üìö Concepts fondamentaux

#### 1. Types de base (Types primitifs)

**TypeScript conna√Æt les types JavaScript de base :**

```typescript
// Types de base
let nom: string = "Alain";           // Texte
let age: number = 50;                // Nombre
let estActif: boolean = true;        // Bool√©en
let donnee: null = null;             // Null
let indefini: undefined = undefined; // Undefined
```

**Comparaison avec 4D :**
- `string` ‚âà `C_TEXT` (cha√Æne de caract√®res)
- `number` ‚âà `C_REAL` ou `C_LONGINT` (nombre)
- `boolean` ‚âà `C_BOOLEAN` (bool√©en)
- `null` ‚âà `Null` (valeur nulle)
- `undefined` ‚âà Variable non initialis√©e

**Dans le projet :**

```typescript
// app/page.tsx
export default function HomePage() {
  return (
    <main className={styles.main}>
      <h1>Home page</h1>  // ‚Üê TypeScript sait que c'est du JSX
    </main>
  );
}
```

---

#### 2. Types complexes : Arrays (Tableaux)

**TypeScript pour les tableaux :**

```typescript
// Tableau de nombres
let nombres: number[] = [1, 2, 3, 4, 5];

// Tableau de textes
let noms: string[] = ["Alain", "Marie", "Pierre"];

// Tableau vide (doit √™tre typ√©)
let vide: string[] = [];
```

**Comparaison avec 4D :**
- `number[]` ‚âà `ARRAY LONGINT`
- `string[]` ‚âà `ARRAY TEXT`

**Dans le projet :**

```typescript
// data/footerButtons.json (charg√© comme array)
const footerButtons: FooterButton[] = [
  { id: "email", image: "/images/...", ... },
  { id: "youtube", image: "/images/...", ... },
];
```

---

#### 3. Types complexes : Objects (Objets)

**TypeScript pour les objets :**

```typescript
// Objet avec types explicites
let personne: {
  nom: string;
  age: number;
  actif: boolean;
} = {
  nom: "Alain",
  age: 50,
  actif: true
};
```

**Comparaison avec 4D :**
- Objet TypeScript ‚âà Table 4D ou Objet 4D
- Champs typ√©s ‚âà Colonnes typ√©es dans une table 4D

**Dans le projet :**

```typescript
// app/layout.tsx
export const metadata: Metadata = {
  title: "Malain et possible",
  description: "Conduite du changement...",
  keywords: ["conduite du changement", "transformation", ...]
};
```

---

#### 4. Interfaces : Contrats pour les objets

**C'est quoi une interface ?**

Une **interface** d√©finit la **structure** d'un objet. C'est un **contrat** : "Tout objet qui respecte cette interface doit avoir ces propri√©t√©s avec ces types."

**Exemple simple :**

```typescript
// D√©finition de l'interface
interface Personne {
  nom: string;
  age: number;
  actif: boolean;
}

// Utilisation de l'interface
let alain: Personne = {
  nom: "Alain",
  age: 50,
  actif: true
};

// ‚ùå ERREUR : Manque la propri√©t√© "actif"
let marie: Personne = {
  nom: "Marie",
  age: 30
  // actif manquant ‚Üí ERREUR TypeScript
};
```

**Comparaison avec 4D :**
- Interface ‚âà Structure de table 4D (d√©finition des colonnes)
- Objet respectant l'interface ‚âà Enregistrement dans la table

**Dans le projet :**

```typescript
// types/footer.ts
export interface FooterButton {
  id: string;
  image: string;
  command: string;
  alt: string;
  url: string | null;      // ‚Üê Peut √™tre string OU null
  tooltip: string;
}

// Utilisation dans Footer.tsx
const button: FooterButton = {
  id: "email",
  image: "/images/Bouton - email.JPG",
  command: "cmd-email",
  alt: "Email",
  url: "mailto:alain@maep.fr",
  tooltip: "M'envoyer un email"
};
```

**Avantage** : Si vous oubliez une propri√©t√© ou mettez le mauvais type, TypeScript vous le dit **imm√©diatement** (avant l'ex√©cution).

---

#### 5. Types Union : "Ceci OU cela"

**C'est quoi un type union ?**

Un **type union** permet de dire : "Cette valeur peut √™tre de type A **OU** de type B."

**Syntaxe :** `typeA | typeB`

**Exemple simple :**

```typescript
// Une valeur peut √™tre un nombre OU une cha√Æne
let valeur: number | string;

valeur = 42;        // ‚úÖ OK : c'est un number
valeur = "quarante-deux"; // ‚úÖ OK : c'est un string
valeur = true;      // ‚ùå ERREUR : boolean n'est pas number | string
```

**Dans le projet :**

```typescript
// types/footer.ts
export interface FooterButton {
  url: string | null;  // ‚Üê url peut √™tre une cha√Æne OU null
}
```

**Explication :**
- Certains boutons ont une URL (ex: `"mailto:alain@maep.fr"`)
- D'autres n'ont pas d'URL (ex: le bouton "Site map" qui ouvre un popup)
- Donc `url` peut √™tre `string` (si URL pr√©sente) ou `null` (si pas d'URL)

**Dans le code :**

```typescript
// utils/buttonHandlers.ts
export const getButtonAction = (
  command: string, 
  url: string | null  // ‚Üê Param√®tre peut √™tre string OU null
): ButtonAction => {
  if (url) {  // TypeScript sait que url est string ici (car diff√©rent de null)
    return { type: 'external', url };
  }
  // ...
};
```

---

#### 6. Types : Alias pour types complexes

**C'est quoi un type ?**

Un **type** (avec `type`) est un **alias** pour un type complexe. C'est comme cr√©er un **raccourci** pour √©viter de r√©p√©ter la m√™me d√©finition.

**Exemple simple :**

```typescript
// Sans type alias (r√©p√©titif)
function traiterDonnee(valeur: string | number | boolean): void { }
function autreFonction(valeur: string | number | boolean): void { }

// Avec type alias (plus lisible)
type Valeur = string | number | boolean;

function traiterDonnee(valeur: Valeur): void { }
function autreFonction(valeur: Valeur): void { }
```

**Dans le projet :**

```typescript
// utils/buttonHandlers.ts
export type ButtonAction = 
  | { type: 'internal'; route: string }
  | { type: 'external'; url: string }
  | { type: 'alert'; message: string };
```

**Explication :**
- `ButtonAction` est un **type union** de 3 objets diff√©rents
- Chaque objet a une propri√©t√© `type` diff√©rente (discriminant)
- TypeScript peut **d√©duire** quel objet est utilis√© selon la valeur de `type`

**Utilisation (type narrowing) :**

```typescript
function traiterAction(action: ButtonAction) {
  if (action.type === 'internal') {
    // TypeScript sait que action.route existe ici
    router.push(action.route);
  } else if (action.type === 'external') {
    // TypeScript sait que action.url existe ici
    window.open(action.url);
  } else {
    // TypeScript sait que action.message existe ici
    alert(action.message);
  }
}
```

**Avantage** : TypeScript **comprend** quelle propri√©t√© est disponible selon le `type`, vous ne pouvez pas acc√©der √† `action.route` si `action.type === 'external'`.

---

#### 7. `as const` : Rendre les valeurs immuables

**C'est quoi `as const` ?**

`as const` dit √† TypeScript : "Cette valeur ne changera **jamais**, c'est une **constante**."

**Exemple sans `as const` :**

```typescript
const ROUTES = {
  HOME: '/',
  ABOUT: '/about'
};

// Type inf√©r√© : { HOME: string; ABOUT: string; }
// ROUTES.HOME peut √™tre modifi√© (th√©oriquement)
```

**Exemple avec `as const` :**

```typescript
const ROUTES = {
  HOME: '/',
  ABOUT: '/about'
} as const;

// Type inf√©r√© : { readonly HOME: '/'; readonly ABOUT: '/about'; }
// ROUTES.HOME est maintenant immuable (readonly)
```

**Dans le projet :**

```typescript
// constants/routes.ts
export const ROUTES = {
  HOME: '/',
  ABOUT: '/about',
  SITEMAP: '/sitemap',
  ABOUT_SITE: '/about-site',
} as const;

export type Route = typeof ROUTES[keyof typeof ROUTES];
// Type Route = '/' | '/about' | '/sitemap' | '/about-site'
```

**Explication :**
- `as const` rend les valeurs **readonly** (immuables)
- `typeof ROUTES` = Type de l'objet ROUTES
- `keyof typeof ROUTES` = Union des cl√©s ('HOME' | 'ABOUT' | 'SITEMAP' | 'ABOUT_SITE')
- `typeof ROUTES[keyof typeof ROUTES]` = Union des **valeurs** ('/' | '/about' | '/sitemap' | '/about-site')

**Avantage** : Le type `Route` repr√©sente **exactement** les valeurs possibles, pas seulement `string`. Si vous essayez d'utiliser une route invalide, TypeScript vous le dit.

```typescript
const maRoute: Route = '/';        // ‚úÖ OK
const maRoute: Route = '/about';   // ‚úÖ OK
const maRoute: Route = '/invalide'; // ‚ùå ERREUR : '/invalide' n'est pas dans Route
```

---

#### 8. `Readonly` : Rendre les propri√©t√©s en lecture seule

**C'est quoi `Readonly` ?**

`Readonly` est un **modificateur** qui rend les propri√©t√©s d'un objet **en lecture seule** (immuables).

**Exemple simple :**

```typescript
interface Personne {
  readonly nom: string;  // ‚Üê Ne peut pas √™tre modifi√© apr√®s cr√©ation
  age: number;           // ‚Üê Peut √™tre modifi√©
}

let alain: Personne = {
  nom: "Alain",
  age: 50
};

alain.nom = "Marie";  // ‚ùå ERREUR : nom est readonly
alain.age = 51;       // ‚úÖ OK : age peut √™tre modifi√©
```

**Dans le projet :**

```typescript
// app/layout.tsx
export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  // ...
}
```

**Explication :**
- Le param√®tre `children` est wrapp√© dans `Readonly<{...}>`
- Cela signifie que l'objet ne peut pas √™tre modifi√© √† l'int√©rieur de la fonction
- C'est une **protection** pour √©viter les modifications accidentelles

**Comparaison avec 4D :**
- `Readonly` ‚âà Table 4D en **lecture seule** (vous ne pouvez pas modifier les enregistrements)

---

#### 9. Fonctions : Types de param√®tres et retour

**TypeScript pour les fonctions :**

```typescript
// Fonction avec types explicites
function addition(a: number, b: number): number {
  return a + b;
}

// Fonction sans retour (void)
function afficher(message: string): void {
  console.log(message);
}

// Fonction avec param√®tre optionnel (?)
function saluer(nom: string, age?: number): void {
  console.log(`Bonjour ${nom}`);
  if (age) {
    console.log(`Vous avez ${age} ans`);
  }
}

// Fonction avec valeur par d√©faut
function multiplier(a: number, b: number = 2): number {
  return a * b;
}
```

**Dans le projet :**

```typescript
// utils/buttonHandlers.ts
export const getRouteForCommand = (command: string): string | null => {
  // ...
  return commandToRouteMap[command] || null;
  //     ‚Üë Retourne string OU null
};
```

**Explication :**
- Param√®tre `command: string` = Le param√®tre est de type `string`
- `: string | null` = La fonction retourne `string` **OU** `null`
- `|| null` = Si la commande n'existe pas, retourne `null`

---

#### 10. G√©n√©riques (Generics) : Fonctions r√©utilisables

**C'est quoi les g√©n√©riques ?**

Les **g√©n√©riques** permettent de cr√©er des fonctions **r√©utilisables** qui travaillent avec **n'importe quel type**.

**Exemple simple :**

```typescript
// Sans g√©n√©rique (r√©p√©titif)
function obtenirPremierElementString(tableau: string[]): string | undefined {
  return tableau[0];
}

function obtenirPremierElementNumber(tableau: number[]): number | undefined {
  return tableau[0];
}

// Avec g√©n√©rique (r√©utilisable)
function obtenirPremierElement<T>(tableau: T[]): T | undefined {
  return tableau[0];
}

// Utilisation
obtenirPremierElement<string>(["a", "b", "c"]);  // ‚Üí string | undefined
obtenirPremierElement<number>([1, 2, 3]);        // ‚Üí number | undefined
```

**Dans le projet :**

```typescript
// constants/routes.ts
export type Route = typeof ROUTES[keyof typeof ROUTES];
//                   ‚Üë G√©n√©rique : extrait les valeurs de ROUTES
```

**Explication :**
- `typeof ROUTES` = Type de l'objet ROUTES
- `keyof typeof ROUTES` = Union des cl√©s ('HOME' | 'ABOUT' | ...)
- `typeof ROUTES[keyof typeof ROUTES]` = Union des valeurs ('/' | '/about' | ...)

**Avantage** : Si vous ajoutez une route dans `ROUTES`, le type `Route` est **automatiquement mis √† jour** sans modifier le code ailleurs.

---

#### 11. Types d'import : `import type`

**C'est quoi `import type` ?**

`import type` permet d'importer **uniquement les types** (pas le code ex√©cutable). Cela permet de supprimer le code inutile apr√®s compilation.

**Exemple :**

```typescript
// Import normal (code + types)
import { FooterButton } from '../types/footer';
// Utilis√© dans le code : FooterButton est pr√©sent dans le JavaScript compil√©

// Import type (types seulement)
import type { FooterButton } from '../types/footer';
// Utilis√© uniquement pour le typage : FooterButton est supprim√© du JavaScript compil√©
```

**Dans le projet :**

```typescript
// app/layout.tsx
import type { Metadata } from "next";
//            ‚Üë Import type : Metadata n'est utilis√© que pour le typage
```

**Avantage** : R√©duit la taille du code JavaScript final (les types sont supprim√©s √† la compilation).

---

#### 12. Types utilitaires : `Record`, `Partial`, `Pick`, etc.

**TypeScript fournit des types utilitaires pr√©-construits :**

**`Record<K, V>` : Objet avec cl√©s et valeurs typ√©es**

```typescript
// Record<string, string> = Objet avec cl√©s string et valeurs string
const routes: Record<string, string> = {
  home: '/',
  about: '/about'
};

// Dans le projet :
// utils/buttonHandlers.ts
const commandToRouteMap: Record<string, string> = {
  [COMMANDS.SITEMAP]: ROUTES.SITEMAP,
  [COMMANDS.ABOUT_SITE]: ROUTES.ABOUT_SITE,
};
```

**`Partial<T>` : Toutes les propri√©t√©s sont optionnelles**

```typescript
interface Personne {
  nom: string;
  age: number;
}

// Partial<Personne> = { nom?: string; age?: number; }
function mettreAJour(personne: Partial<Personne>): void {
  // Toutes les propri√©t√©s sont optionnelles
}
```

**`Pick<T, K>` : S√©lectionner certaines propri√©t√©s**

```typescript
interface Personne {
  nom: string;
  age: number;
  email: string;
}

// Pick<Personne, 'nom' | 'age'> = { nom: string; age: number; }
type PersonneBasique = Pick<Personne, 'nom' | 'age'>;
```

---

### üîç Inf√©rence de types : TypeScript devine les types

**TypeScript est intelligent : il devine (inf√®re) les types automatiquement.**

**Exemple :**

```typescript
// TypeScript inf√®re automatiquement que nombre est de type number
let nombre = 42;  // Type : number

// TypeScript inf√®re automatiquement que texte est de type string
let texte = "Hello";  // Type : string

// TypeScript inf√®re automatiquement le type de retour
function addition(a: number, b: number) {
  return a + b;  // Type inf√©r√© : number
}
```

**Dans le projet :**

```typescript
// app/page.tsx
export default function HomePage() {
  // TypeScript inf√®re automatiquement le type de retour : JSX.Element
  return (
    <main className={styles.main}>
      <h1>Home page</h1>
    </main>
  );
}
```

**Quand d√©clarer explicitement les types ?**

**D√©clarez explicitement quand :**
- ‚úÖ La fonction est publique (export√©e)
- ‚úÖ La fonction a une logique complexe
- ‚úÖ Vous voulez documenter l'intention

**Laissez TypeScript inf√©rer quand :**
- ‚úÖ La valeur est √©vidente
- ‚úÖ Le type est simple
- ‚úÖ Vous √™tes dans une fonction interne

---

### üìñ Exemples concrets du projet

#### Exemple 1 : Interface FooterButton

```typescript
// types/footer.ts
export interface FooterButton {
  id: string;
  image: string;
  command: string;
  alt: string;
  url: string | null;      // ‚Üê Union type : string OU null
  tooltip: string;
}

// Utilisation dans Footer.tsx
const button: FooterButton = {
  id: "email",
  image: "/images/Bouton - email.JPG",
  command: "cmd-email",
  alt: "Email",
  url: "mailto:alain@maep.fr",  // ‚Üê string
  tooltip: "M'envoyer un email"
};

const buttonSansUrl: FooterButton = {
  id: "sitemap",
  // ...
  url: null,  // ‚Üê null (pas de string)
  // ...
};
```

**Points cl√©s :**
- `interface` d√©finit la structure
- `string | null` = Union type (peut √™tre l'un ou l'autre)
- TypeScript v√©rifie que toutes les propri√©t√©s sont pr√©sentes et du bon type

---

#### Exemple 2 : Type ButtonAction (Union discrimin√©e)

```typescript
// utils/buttonHandlers.ts
export type ButtonAction = 
  | { type: 'internal'; route: string }
  | { type: 'external'; url: string }
  | { type: 'alert'; message: string };

export const getButtonAction = (
  command: string, 
  url: string | null
): ButtonAction => {
  const route = getRouteForCommand(command);
  if (route) {
    return { type: 'internal', route };  // ‚Üê TypeScript sait que c'est ButtonAction
  }
  
  if (url) {
    return { type: 'external', url };  // ‚Üê TypeScript sait que c'est ButtonAction
  }
  
  return { type: 'alert', message: `Commande: ${command}` };
};
```

**Points cl√©s :**
- `type` = Alias pour un union type
- Union discrimin√©e (chaque objet a une propri√©t√© `type` diff√©rente)
- TypeScript peut **narrower** le type selon la valeur de `type`

**Utilisation avec type narrowing :**

```typescript
function traiterAction(action: ButtonAction) {
  if (action.type === 'internal') {
    // TypeScript sait que action.route existe
    router.push(action.route);  // ‚úÖ OK
    // router.push(action.url);  // ‚ùå ERREUR : url n'existe pas sur 'internal'
  } else if (action.type === 'external') {
    // TypeScript sait que action.url existe
    window.open(action.url);  // ‚úÖ OK
  } else {
    // TypeScript sait que action.message existe
    alert(action.message);  // ‚úÖ OK
  }
}
```

---

#### Exemple 3 : Constants avec `as const`

```typescript
// constants/routes.ts
export const ROUTES = {
  HOME: '/',
  ABOUT: '/about',
  SITEMAP: '/sitemap',
  ABOUT_SITE: '/about-site',
} as const;

// Type extrait automatiquement
export type Route = typeof ROUTES[keyof typeof ROUTES];
// Type Route = '/' | '/about' | '/sitemap' | '/about-site'
```

**Points cl√©s :**
- `as const` rend les valeurs **readonly** (immuables)
- `typeof ROUTES` = Type de l'objet ROUTES
- `keyof typeof ROUTES` = Union des cl√©s
- `typeof ROUTES[keyof typeof ROUTES]` = Union des valeurs

**Avantage :**
- Si vous ajoutez une route dans `ROUTES`, le type `Route` est automatiquement mis √† jour
- Impossible d'utiliser une route invalide (TypeScript refuse)

---

#### Exemple 4 : Fonction avec types explicites

```typescript
// utils/buttonHandlers.ts
export const getRouteForCommand = (command: string): string | null => {
  const commandToRouteMap: Record<string, string> = {
    [COMMANDS.SITEMAP]: ROUTES.SITEMAP,
    [COMMANDS.ABOUT_SITE]: ROUTES.ABOUT_SITE,
  };

  return commandToRouteMap[command] || null;
};
```

**Points cl√©s :**
- Param√®tre `command: string` = Type explicite
- `: string | null` = Type de retour (union type)
- `Record<string, string>` = Type utilitaire pour objet
- `|| null` = Si la commande n'existe pas, retourne `null`

---

### üéØ Bonnes pratiques TypeScript

#### 1. Toujours typer les fonctions export√©es

**‚úÖ BON :**
```typescript
export function getRouteForCommand(command: string): string | null {
  // ...
}
```

**‚ùå MAUVAIS :**
```typescript
export function getRouteForCommand(command) {
  // ...
}
```

**Pourquoi ?** : Les fonctions export√©es sont utilis√©es ailleurs, le typage documente le contrat.

---

#### 2. Utiliser `interface` pour les objets, `type` pour les unions

**‚úÖ BON :**
```typescript
// Interface pour objet
interface FooterButton {
  id: string;
  // ...
}

// Type pour union
type ButtonAction = 
  | { type: 'internal'; route: string }
  | { type: 'external'; url: string };
```

**Pourquoi ?** : Convention claire et lisible.

---

#### 3. √âviter `any` (utiliser `unknown` si n√©cessaire)

**‚ùå MAUVAIS :**
```typescript
function traiter(donnee: any) {
  // ...
}
```

**‚úÖ BON :**
```typescript
function traiter(donnee: unknown) {
  if (typeof donnee === 'string') {
    // TypeScript sait que donnee est string ici
  }
}
```

**Pourquoi ?** : `any` d√©sactive la v√©rification de types. `unknown` force √† v√©rifier le type avant utilisation.

---

#### 4. Utiliser `as const` pour les constantes

**‚úÖ BON :**
```typescript
const ROUTES = {
  HOME: '/',
  ABOUT: '/about'
} as const;
```

**Pourquoi ?** : Rend les valeurs immuables et permet l'extraction de types.

---

#### 5. Utiliser `import type` pour les imports de types uniquement

**‚úÖ BON :**
```typescript
import type { Metadata } from "next";
```

**Pourquoi ?** : R√©duit la taille du code JavaScript compil√©.

---

### üîó Liens avec les principes du projet

**TypeScript et s√©paration des pr√©occupations :**

**Backend pur (`utils/`) :**
```typescript
// Types explicites pour la logique m√©tier
export const getButtonAction = (
  command: string, 
  url: string | null
): ButtonAction => {
  // ...
};
```
‚Üí Types r√©utilisables, testables, utilisables partout

**Frontend (`components/`) :**
```typescript
// Types pour l'interactivit√© React
interface FooterButtonProps extends FooterButton {
  onButtonClick: (command: string, url: string | null) => void;
}
```
‚Üí Types sp√©cifiques √† React (props, event handlers)

**R√©sultat :** S√©paration claire entre logique m√©tier (types r√©utilisables) et logique de pr√©sentation (types React).

---

### ‚ùì Questions fr√©quentes

#### Q : Dois-je typer toutes les variables ?

**R :** Non, laissez TypeScript inf√©rer quand c'est √©vident :

```typescript
// ‚úÖ OK : TypeScript inf√®re automatiquement
let nombre = 42;  // Type : number

// ‚úÖ OK : Type explicite n√©cessaire pour la documentation
function calculer(a: number, b: number): number {
  return a + b;
}
```

#### Q : Quelle diff√©rence entre `interface` et `type` ?

**R :** En pratique, tr√®s peu pour les objets :

- `interface` : Peut √™tre √©tendue (`extends`), peut fusionner avec d'autres interfaces
- `type` : Plus flexible (unions, intersections, etc.)

**Convention** : Utilisez `interface` pour les objets, `type` pour les unions/intersections.

#### Q : Quand utiliser `any` ?

**R :** **Jamais** (ou presque). Utilisez `unknown` si vous ne connaissez pas le type :

```typescript
// ‚ùå MAUVAIS
function traiter(donnee: any) {
  donnee.toto();  // Pas d'erreur, mais peut planter √† l'ex√©cution
}

// ‚úÖ BON
function traiter(donnee: unknown) {
  if (typeof donnee === 'object' && donnee !== null && 'toto' in donnee) {
    (donnee as { toto: () => void }).toto();  // V√©rification explicite
  }
}
```

---

### üìö Ressources suppl√©mentaires

- [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/intro.html)
- [TypeScript Playground](https://www.typescriptlang.org/play) : Testez TypeScript en ligne
- [Exemples TypeScript du projet](https://github.com/microsoft/TypeScript-Examples)

---

**N'h√©sitez pas √† me poser des questions sp√©cifiques sur TypeScript dans le contexte de votre projet !**
