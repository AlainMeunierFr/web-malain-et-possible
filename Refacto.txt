# Refactorisation noms canoniques (TypeDeContenu.propriété)

## Objectif

Faire en sorte que chaque concept metier définit dans les JSON sous le vocable de TypeDeContenu soit utilisé dans tout le code en respectant des **noms canoniques** sous la forme :
- [TypeDeContenu] tel que listés en ### ci-dessous
- [TypeDeContenu].[propriété] tels que listés en - ci-dessous

## Liste des noms
La liste exhausitive à date est la suivante :
### titreDePage
- titreDePage.texte

### titre
- titre.texte

### hero
- hero.titre
- hero.sousTitre
- hero.description
- hero.callToAction.texte
- hero.callToAction.action

### profil
- profil.titre
- profil.jobTitle
- profil.slug
- profil.route
- profil.cvPath

### domaineDeCompetence
- domaineDeCompetence.titre
- domaineDeCompetence.contenu
- domaineDeCompetence.auteur

### competence
- competence.titre
- competence.image
- competence.icon
- competence.description
- competence.auteur
- competence.bouton.texte
- competence.bouton.action

### experienceEtApprentissage
- experienceEtApprentissage.id
- experienceEtApprentissage.categorie
- experienceEtApprentissage.description
- experienceEtApprentissage.periode
- experienceEtApprentissage.titre

### temoignage
- temoignage.nom
- temoignage.fonction
- temoignage.photo
- temoignage.temoignage

### detournementVideo
- detournementVideo.id
- detournementVideo.titreVideoDetournee
- detournementVideo.videoDetournee
- detournementVideo.titreVideoOriginale
- detournementVideo.videoOriginale
- detournementVideo.pourLeCompteDe
- detournementVideo.date
- detournementVideo.pitch
- detournementVideo.droitsAuteur
- detournementVideo.linkedin

### texteLarge
- texteLarge.texte

### video
- video.urlYouTube
- video.lancementAuto

### callToAction
- callToAction.action

### groupeDeBoutons
- groupeDeBoutons.taille
- groupeDeBoutons.boutons

### bouton
- bouton.id
- bouton.icone
- bouton.texte
- bouton.url
- bouton.command

## Liste des concepts techniques concernés
Les **noms canoniques** doivent être respectés dans toute la chaine technique

JSON → Types TS → Reader → Mapping type→composant → Composants → Classes dans le DOM → Sélecteurs CSS → Règles CSS
         ↑                    ↑              ↑              ↑                  ↑
    (TypeDeContenu)    (quelle page/quoi)  (HTML+classes)  (identité style)  (apparence)
↑
BDD (scénarios avec syntaxe typeDeContenu.propriété)
TU / TI (rédaction alignée sur les mêmes concepts)

### 1. Types / interfaces TypeScript
- Définition des TypeDeContenu et de leurs propriétés (ex. `indexReader.ts` : `ElementTemoignage`, `ElementHero`). Alignés sur la structure JSON.

### 2. Reader / lecture et normalisation
- Code qui lit le JSON, le valide et le normalise (ex. `readPageData`, `indexReader`). Produit des données typées pour le front.

### 3. Mapping type → composant
- Correspondance entre un TypeDeContenu et le composant qui le rend (ex. dans `PageContentRenderer` : `listeDeTemoignages` → `Temoignages`, `hero` → `HeroSection`).

### 4. Composants (React)
- Composants qui reçoivent les données typées et rendent le HTML. Ils appliquent les **noms de classes** (convention typeDeContenu.propriété) sur les éléments du DOM.

### 5. Noms de classes (identité du style)
- Convention des classes dans le HTML : deux classes par propriété (`typeDeContenu` + `propriété`) pour obtenir le sélecteur `.typeDeContenu.propriété`. C’est le lien entre données et styles.

### 6. Sélecteurs CSS
- Les sélecteurs dans les feuilles de style (ex. `.temoignage.nom`, `.hero.titre`) qui ciblent ces classes. Ils portent l’**identité** du style (nom canonique).

### 7. Règles CSS (propriétés de style)
- Les blocs de règles (font, couleur, taille, layout, etc.) attachés à ces sélecteurs. C’est l’aspect visuel.

### 8. Scénarios BDD (syntaxe pour concepts métier)
- Utiliser une **syntaxe dédiée** dans les steps Gherkin pour introduire les concepts métier avec les **noms canoniques** (ex. `typeDeContenu.propriété` ou une notation réservée comme `[temoignage.nom]`). On retire l’ambiguïté sur ce qui est vérifié (quel bloc, quelle propriété) et on aligne le langage des scénarios sur le reste de la chaîne (types, composants, CSS).

### 9. Tests unitaires (TU) et tests d’intégration (TI)
- Rédiger les TU et TI en s’appuyant sur les **mêmes concepts** : assertions sur les classes (typeDeContenu.propriété), sur les composants et sur la forme des données. Les sélecteurs, noms de classes et types utilisés dans les tests doivent être cohérents avec les noms canoniques et la chaîne technique (JSON → composants → CSS), pour éviter la dérive et faciliter la maintenance.

### 10. Pages / routes
- Quelle page charge quel JSON (ex. page « Mes profils » → `mes-profils.json`). Détermine quels TypeDeContenu sont disponibles sur la page.

### 11. Script d’export / analyse des styles
- Outil qui parcourt le CSS (ex. `extract-text-styles.ts`) pour produire la liste des sélecteurs (TXT, Excel). Permet de vérifier que les noms canoniques sont bien présents (chaîne inverse : CSS → liste).


Note à propos de "TypeDeContenu"
Afin que les concepts 

Les types de contenus et toutes leurs propriétés sont contenu dans un "container" React/CSS portant le nom .typeDeContenu
= Wrapper / conteneur (div) = layout, responsive, délimitation du bloc → .typeDeContenu (ex. .profil).

Les éléments graphiques ajoutés dans le Wrapper / conteneur sont préfixé ".ui".
Mais contenu dans un Wrapper / conteneur "typé", ils sont préfixés du nom du TypeDeContenu : [typeDecontenu].ui.[element]
Exemple : Carte / zone cliquable (Link ou zone UX) = choix UX → .typeDeContenu.ui-card (ex. .profil.ui-card)
